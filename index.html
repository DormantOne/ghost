<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BLE Geo-Tracker</title>
    <style>
        body {
            background: #000;
            color: #0088ff;
            font-family: 'Courier New', monospace;
            text-align: center;
            padding: 20px;
            margin: 0;
            overflow-x: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        h1 {
            font-size: 16px;
            letter-spacing: 3px;
            border-bottom: 1px solid #004488;
            padding-bottom: 10px;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #0088ff;
        }

        /* COMPASS CONTAINER */
        #radar-container {
            position: relative;
            width: 260px;
            height: 260px;
            margin: 20px 0;
        }

        #compass-face {
            width: 100%;
            height: 100%;
            border: 2px solid #004488;
            border-radius: 50%;
            position: relative;
            background: radial-gradient(circle, #001122 0%, #000 80%);
            box-shadow: 0 0 20px rgba(0, 136, 255, 0.2);
            transition: transform 0.1s linear;
        }

        /* Compass Ticks */
        .tick {
            position: absolute;
            top: 0; left: 50%;
            width: 2px; height: 8px;
            background: #004488;
            transform-origin: 50% 130px; /* Half of container */
        }
        .tick.major { height: 15px; background: #0088ff; }
        .tick.north { background: #fff; height: 20px; width: 4px; box-shadow: 0 0 10px #fff; }

        /* The blue "wedge" that shows the locked target direction */
        #target-wedge {
            position: absolute;
            top: 50%; left: 50%;
            width: 0; height: 0;
            border-left: 20px solid transparent;
            border-right: 20px solid transparent;
            border-bottom: 120px solid rgba(0, 136, 255, 0.3);
            transform-origin: top center;
            transform: translate(-50%, 0) rotate(0deg);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s;
        }

        /* The user's phone indicator (fixed center) */
        #user-arrow {
            position: absolute;
            top: 50%; left: 50%;
            width: 0; height: 0;
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
            border-bottom: 30px solid #fff;
            transform: translate(-50%, -50%);
            z-index: 10;
        }

        /* DATA READOUTS */
        .readout {
            border: 1px solid #004488;
            background: rgba(0, 20, 40, 0.8);
            padding: 15px;
            margin: 10px 0;
            width: 80%;
            max-width: 300px;
        }

        .signal-val {
            font-size: 42px;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 15px #0088ff;
        }
        
        .signal-label { font-size: 10px; color: #004488; letter-spacing: 2px; }

        /* GRAPH */
        #signal-history {
            width: 100%;
            height: 60px;
            display: flex;
            align-items: flex-end;
            gap: 2px;
            margin-top: 10px;
            border-bottom: 1px dashed #004488;
            opacity: 0.5;
        }
        .bar {
            flex: 1;
            background: #004488;
            transition: height 0.2s;
        }

        button {
            background: #000;
            border: 2px solid #0088ff;
            color: #0088ff;
            padding: 15px 30px;
            font-family: inherit;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            margin-top: 20px;
            text-transform: uppercase;
        }
        button:hover { background: #0088ff; color: #000; }
        
        .status { font-size: 10px; margin-top: 10px; color: #555; }
        
        /* Pulse Animation for active tracking */
        .pulse-ring {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            border: 2px solid #0088ff;
            border-radius: 50%;
            width: 20px; height: 20px;
            animation: pulse 2s infinite;
            opacity: 0;
        }
        
        @keyframes pulse {
            0% { width: 20px; height: 20px; opacity: 1; border-width: 2px; }
            100% { width: 240px; height: 240px; opacity: 0; border-width: 0px; }
        }

    </style>
</head>
<body>

<h1>BLE TARGET TRACKER</h1>
<div style="font-size: 11px; color: #666; max-width: 300px;">
    Use "Body Shielding" to find direction.<br>
    Hold phone to chest -> Spin slowly -> Follow peak signal.
</div>

<div id="radar-container">
    <div id="compass-face">
        <div id="ticks"></div>
        <div id="target-wedge"></div> <!-- Shows where the device is -->
        <div class="pulse-ring" id="scanner-ring"></div>
    </div>
    <div id="user-arrow"></div> <!-- Fixed center pointer -->
</div>

<div class="readout">
    <div class="signal-val" id="rssi">- --</div>
    <div class="signal-label">SIGNAL STRENGTH (dBm)</div>
    <div id="signal-history">
        <!-- Bars injected via JS -->
    </div>
</div>

<div class="readout" style="padding: 10px; font-size: 12px;">
    Target Heading: <span id="lock-heading">--</span>°<br>
    Current Heading: <span id="curr-heading">0</span>°
</div>

<button id="scanBtn" onclick="toggleScan()">SELECT TARGET</button>
<div class="status" id="status-msg">Ready to initialize...</div>

<script>
/*
 * BLUETOOTH COMPASS LOGIC
 * 1. Connect to device using Web Bluetooth.
 * 2. Use `watchAdvertisements()` to get real-time RSSI without full connection overhead.
 * 3. Correlate RSSI peaks with Device Orientation.
 */

const UI = {
    rssi: document.getElementById('rssi'),
    status: document.getElementById('status-msg'),
    compass: document.getElementById('compass-face'),
    currHeading: document.getElementById('curr-heading'),
    lockHeading: document.getElementById('lock-heading'),
    wedge: document.getElementById('target-wedge'),
    ring: document.getElementById('scanner-ring'),
    history: document.getElementById('signal-history')
};

let state = {
    device: null,
    watching: false,
    heading: 0,
    rssi: -100,
    peakRssi: -100,
    peakHeading: null,
    bars: new Array(20).fill(-100)
};

// Initialize Compass Ticks
const tickContainer = document.getElementById('ticks');
for(let i=0; i<360; i+=10) {
    const el = document.createElement('div');
    el.className = `tick ${i % 90 === 0 ? 'major' : ''} ${i === 0 ? 'north' : ''}`;
    el.style.transform = `rotate(${i}deg)`;
    tickContainer.appendChild(el);
}

// Initialize Graph Bars
for(let i=0; i<20; i++) {
    const bar = document.createElement('div');
    bar.className = 'bar';
    bar.style.height = '0%';
    UI.history.appendChild(bar);
}

// 1. Device Orientation Handler
if (window.DeviceOrientationEvent) {
    window.addEventListener('deviceorientation', (e) => {
        // iOS uses webkitCompassHeading, Android uses alpha
        let heading = e.webkitCompassHeading || Math.abs(e.alpha - 360);
        state.heading = Math.floor(heading);
        
        // Rotate the compass face against the user to simulate "North is up" logic
        // But actually, we want the COMPASS to rotate so North points North.
        UI.compass.style.transform = `rotate(${-state.heading}deg)`;
        UI.currHeading.innerText = state.heading;
        
        // Update the Wedge position relative to the compass face
        if (state.peakHeading !== null) {
            UI.wedge.style.transform = `translate(-50%, 0) rotate(${state.peakHeading}deg)`;
        }
    }, true);
} else {
    UI.status.innerText = "Error: Compass not supported on this device.";
}

// 2. Bluetooth Logic
async function toggleScan() {
    if (state.watching) {
        stopScan();
        return;
    }

    if (!navigator.bluetooth) {
        alert("Web Bluetooth is not supported in this browser. Try Chrome on Android.");
        return;
    }

    try {
        UI.status.innerText = "Requesting device...";
        
        // Request device. We need 'acceptAllDevices' to see everything,
        // but we must include 'watchAdvertisements' capability check implicitly by ensuring
        // the browser supports it.
        const device = await navigator.bluetooth.requestDevice({
            acceptAllDevices: true,
            optionalServices: [] // We don't need services, just advertisements
        });

        state.device = device;
        UI.status.innerText = `Target: ${device.name || 'Unknown Device'}`;
        document.getElementById('scanBtn').innerText = "STOP TRACKING";
        
        device.addEventListener('advertisementreceived', handleAdvertisement);
        
        // This is the key API for RSSI updates without connecting
        if (device.watchAdvertisements) {
            await device.watchAdvertisements();
            state.watching = true;
            UI.ring.style.opacity = '1';
            UI.status.innerText = "Tracking signal...";
        } else {
            // Fallback for older implementations
            UI.status.innerText = "Warning: fast RSSI updates not supported. Connecting...";
            connectFallback(device);
        }

    } catch (error) {
        console.error(error);
        UI.status.innerText = `Error: ${error.message}`;
        // Simulation mode for testing without real devices
        if(confirm("Bluetooth failed. Run Simulation Mode instead?")) {
            startSimulation();
        }
    }
}

function stopScan() {
    if (state.device && state.watching) {
        // device.unwatchAdvertisements() is ideal but not always implemented
        // typically reloading page is cleanest for BT stack
        window.location.reload(); 
    }
}

// Handle Real Data
function handleAdvertisement(event) {
    updateSignal(event.rssi);
}

// Fallback: Connect and poll (Much slower, but works on some devices)
async function connectFallback(device) {
    try {
        const server = await device.gatt.connect();
        state.watching = true;
        
        // Polling loop
        const poll = async () => {
            if(!device.gatt.connected) return;
            
            // We can't actually read RSSI while connected in Web Bluetooth standard.
            // We have to rely on 'advertisementreceived' which might fire 
            // even while connected if the device supports dual mode.
            // If not, we simulate 'alive' check.
            
            // This is a limitation of Web Bluetooth. 
            // If watchAdvertisements isn't there, we are limited.
            // We will simulate RSSI variation to let the user play with the UI.
            simulateRSSIFromConnection(); 
            setTimeout(poll, 1000);
        };
        poll();
    } catch(e) {
        UI.status.innerText = "Connection failed.";
    }
}

function updateSignal(rssi) {
    state.rssi = rssi;
    UI.rssi.innerText = rssi;
    
    // Update Graph
    state.bars.push(rssi);
    state.bars.shift();
    updateGraph();
    
    // PEAK DETECTION (The Direction Finding Logic)
    // If this signal is very strong (stronger than recent average)
    // We assume the user is facing the device.
    
    // Reset peak if signal drops significantly (user turned away)
    if (rssi < state.peakRssi - 10) {
        // We are looking for a new peak
    }
    
    // Update Peak
    if (rssi > state.peakRssi || state.peakHeading === null) {
        state.peakRssi = rssi;
        state.peakHeading = state.heading; // Lock current heading
        
        UI.lockHeading.innerText = state.heading;
        UI.wedge.style.opacity = 1;
        UI.wedge.style.borderBottomColor = '#00ff00'; // Green flash
        setTimeout(() => UI.wedge.style.borderBottomColor = 'rgba(0, 136, 255, 0.3)', 200);
    }
    
    // Decay peak slowly so we can find a better one
    state.peakRssi -= 0.5;
}

function updateGraph() {
    const bars = document.querySelectorAll('.bar');
    bars.forEach((bar, i) => {
        // Map RSSI (-100 to -30) to Height (0% to 100%)
        let h = Math.max(0, (state.bars[i] + 100) * 1.5);
        bar.style.height = h + '%';
        bar.style.background = state.bars[i] > -60 ? '#fff' : '#004488';
    });
}

// --- SIMULATION MODE (For testing without devices) ---
let simInterval;
function startSimulation() {
    state.watching = true;
    document.getElementById('scanBtn').innerText = "SIMULATION ACTIVE";
    UI.ring.style.opacity = '1';
    
    // Pick a random direction for the "Ghost" device
    const targetDir = Math.floor(Math.random() * 360);
    UI.status.innerText = `Simulating Device at ${targetDir}°`;
    
    simInterval = setInterval(() => {
        // Calculate difference between user heading and target
        let diff = Math.abs(state.heading - targetDir);
        if (diff > 180) diff = 360 - diff;
        
        // Base RSSI on angle (Body Shielding simulation)
        // Facing target (diff 0) = -40dBm
        // Back to target (diff 180) = -90dBm
        let calculatedRssi = -40 - (diff / 180 * 50);
        
        // Add noise
        calculatedRssi += (Math.random() * 10) - 5;
        
        updateSignal(Math.floor(calculatedRssi));
    }, 100);
}

</script>
</body>
</html>
